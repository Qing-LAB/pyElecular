# Change log
#
# 2025/05/06
# Considering change how the information of FigureWindow is managed. We should
# use a dictionary of dictionaries to hold key:info pair. The key should
# be a unique identifier/number generated by the PlotWindow class. The info
# dict should contain the information on the figure window, including the status
# of the figures. If the figures are closed, it will try to store the picture
# of the figures in different formats and release the fig instance/handle such
# that the memory of the pyplot figure can be released. The closed figure
# can be displayed and saved but not changed. The FigureWindow associated
# with each fig will be stored and when activated, will be notified
# to update the drawing and clickable items.
#
# 2025/05/03
# Clean up code to implement the following functions:
#   1. FigureWindow will show its cap with suptitle of the figure
#   2. FigureWindow will have different title color if the figure is the
#       current figure of plt
#   3. Use try-except-finally to address potential errors
#   4. PlotWindow do not actively change the current figure, but rather
#       just try to keep track of the active figure and update FigureWindow
#   5. Add figure management by name and fig_num

import logging
import random
import sys

import intercepts
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QColor
from PyQt6.QtWidgets import (QApplication, QFileDialog, QListWidget,
                             QListWidgetItem, QMainWindow, QMenu, QMessageBox,
                             QTextEdit, QVBoxLayout, QWidget)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__file__ + "." + __name__)


class FigureWindow(QMainWindow):
    """This window class shows one figure as a separate window. When the user
    closes the figure window, the parent will be notified to keep track of the
    status of individual figures.

    Args:
        parent : 
            parent window that will receive notification when the user closes
            the figure window.
    """

    def __init__(self, fig: Figure, parent=None):
        super().__init__(parent)
        self.fig_ready = False
        try:
            self.redraw_fig(fig)
            self.fig_ready = True
        except Exception as e:
            logger.error("Error when initializing FigureWindow.")
            logger.exception(e, exc_info=True, stack_info=True)

    def redraw_fig(self, fig):
        if fig and fig.get_axes():
            self.fig = fig
            self.fig_num = fig.number
            self.fig_suptitle = fig.get_suptitle()

            self.canvas = FigureCanvas(fig)
            self.setCentralWidget(self.canvas)
            self.setWindowTitle(f"Figure {fig.number}")
            self.setGeometry(300, 300, 600, 400)

    def closeEvent(self, event):
        try:
            if self.fig_ready and self.parent() is not None:
                if hasattr(self.parent(), 'notify_figure_window_closed'):
                    self.parent().notify_figure_window_closed(self.fig.number)
        except Exception as e:
            logger.error("Error when FigureWindow try to invoke parent window notify_figure_window_closed() method.")
            logger.exception(e, exc_info=True, stack_info=True)
        finally:
            super().closeEvent(event)


def hook_figure_creation(*args, **kwargs):
    """
    This is the hook function to monitor the call to pyplot.figure() and maintain the figure list
    Args:
        *args:
        **kwargs:

    Returns:

    """
    if 'facecolor' in kwargs:
        facecolor = kwargs['facecolor']
        del kwargs['facecolor']
    else:
        facecolor = None

    if 'edgecolor' in kwargs:
        edgecolor = kwargs['edgecolor']
        del kwargs['edgecolor']
    else:
        edgecolor = None

    if 'frameon' in kwargs:
        frameon = kwargs['frameon']
        del kwargs['frameon']
    else:
        frameon = True

    if 'FigureClass' in kwargs:
        FigureClass = kwargs['FigureClass']
        del kwargs['FigureClass']
    else:
        FigureClass = matplotlib.figure.Figure

    if 'clear' in kwargs:
        clear = kwargs['clear']
        del kwargs['clear']
    else:
        clear = False
    result = _(*args, facecolor=facecolor, edgecolor=edgecolor, frameon=frameon, FigureClass=FigureClass, clear=clear,
               **kwargs)
    PlotWindow._on_figure_created(result)
    return result


# --- PlotWindow: main plot manager window ---
class PlotWindow(QMainWindow):
    """This is the Matplotlib figure manager. Overall it will list the existing 
    matplotlib.pyplot figures, and display the info associated with each figure.
    For listed figures, if the figure has been closed by the function call 
    plt.close(), the status will be shown as (closed). Otherwise the figure
    will be marked as not closed. When clicking the figure that is not closed, 
    a call to plt.figure(fig_num) will be made such that the later call to 
    pyplot functions will modify this "active" figure.
    Double click the figure will bring up the figure as a separate window.
    In addition, the window provides save function to export the figure into 
    PNG, PDF or SVG formats.

    Args:
        parent : 
            give the parent object for this window.
        allow_full_close : 
            if True, when the user clicks the close button of the window,
            the window will be closed. Otherwise, the window will only
            hide and the parent/user can bring the window shown/active again
            later by calling the function show_window()        

    """
    figure_creation_hook = False
    _figure_uid = dict()
    _figure_track_list = dict()
    _instance = None
    _next_fig_uid = random.randint(1, 1000)

    def __init__(self, parent=None, allow_full_close=False):
        super().__init__(parent)

        if not self.figure_creation_hook:
            intercepts.register(plt.figure, hook_figure_creation)
            self.figure_creation_hook = True

        self.setWindowTitle("Plot Manager")
        self.setGeometry(100, 100, 400, 600)
        self.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.WindowStaysOnTopHint)

        self.allow_full_close = allow_full_close

        self.list_widget = QListWidget()
        self.info_window = QTextEdit()
        self.info_window.setReadOnly(True)

        layout = QVBoxLayout()
        layout.addWidget(self.list_widget)
        layout.addWidget(self.info_window)

        main_widget = QWidget()
        main_widget.setLayout(layout)
        self.setCentralWidget(main_widget)

        self.list_widget.itemClicked.connect(self._on_figure_selected)
        self.list_widget.itemDoubleClicked.connect(self._on_figure_double_clicked)
        self.list_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self._open_context_menu)
        PlotWindow._instance = self

    @classmethod
    def _check_fig_in_list(cls, fig: Figure) -> bool:
        return fig in cls._figure_uid.values()

    @classmethod
    def _get_fig_info_in_list(cls, fig: Figure) -> dict:
        for key, value in cls._figure_uid.items():
            if value == fig:
                return cls._figure_track_list[key]
        return {}

    @classmethod
    def _update_fig_info_in_list(cls, fig: Figure, **kwargs):
        for key, value in cls._figure_uid.items():
            if value == fig:
                if key in cls._figure_track_list:
                    cls._figure_track_list[key].update(kwargs)
                else:
                    cls._figure_track_list[key] = kwargs
                return
        unique_key = cls._next_fig_uid
        cls._next_fig_uid += 1

        cls._figure_uid[unique_key] = fig
        cls._figure_track_list[unique_key] = kwargs

    @staticmethod
    def _on_figure_created(fig: Figure):
        """
        This will be called by the hook function intercepting pyplot.figure().
        This functino will link the close_event for the figure to _on_figure_closed.
        Args:
            fig:

        Returns:

        """
        try:
            if not PlotWindow._check_fig_in_list(fig):
                logger.debug(f"Figure {fig.number} id({id(fig)}) created.")
                cid = fig.canvas.mpl_connect('close_event', PlotWindow._on_figure_closed)
                PlotWindow._update_fig_info_in_list(fig, **{'created': True, 'closed': False, 'close_event_cid': cid})
                PlotWindow._instance._update_fig_list()
        except Exception as e:
            logger.error("Error when monitoring figure creation")
            logger.exception(e, exc_info=True, stack_info=True)

    @staticmethod
    def _on_figure_closed(event):
        try:
            fig = event.canvas.figure
            if PlotWindow._check_fig_in_list(fig):
                fig.canvas.mpl_disconnect(PlotWindow._get_fig_info_in_list(fig)['close_event_cid'])
                PlotWindow._update_fig_info_in_list(fig, **{'closed': True})
            else:
                logger.warning(f"Warning: fig {id(fig)} was not in the figure track list.")
            PlotWindow._instance._update_fig_list()
            logger.debug(f"Figure {fig.number} closed.")
        except Exception as e:
            logger.error("Error when monitoring figure closing")
            logger.exception(e, exc_info=True, stack_info=True)

    def _format_figure_name(self, fig: Figure, close_flag: bool) -> str:
        suptitle = fig.get_suptitle()
        if suptitle:
            figure_name = f"Figure {fig.number} ({suptitle})"
        else:
            figure_name = f"Figure {fig.number} (untitled)"
        if close_flag:
            figure_name += " (closed)"
        return figure_name

    def add_figure(self, fig: Figure):
        try:
            self._on_figure_created(fig)
            item = QListWidgetItem(self._format_figure_name(fig, False))
            item.setData(Qt.ItemDataRole.UserRole, fig)
            self.list_widget.addItem(item)
            self._update_fig_list()
        except Exception as e:
            logger.error("Error when adding figure")
            logger.exception(e, exc_info=True, stack_info=True)

    def _update_fig_list(self):
        try:
            for index in range(self.list_widget.count()):
                item = self.list_widget.item(index)
                fig = item.data(Qt.ItemDataRole.UserRole)
                if PlotWindow._check_fig_in_list(fig):
                    fig_info = PlotWindow._get_fig_info_in_list(fig)
                    close_flag = fig_info['closed']
                    fig_name = self._format_figure_name(fig, close_flag)
                    if fig is plt.gcf():
                        fig_name += "*"
                    item.setText(fig_name)
                    if close_flag:
                        item.setForeground(QColor("red"))
                    else:
                        item.setForeground(QColor("green"))
        except Exception as e:
            logger.error("Error when updating figure list")
            logger.exception(e, exc_info=True, stack_info=True)

    def _update_info_panel(self, fig: Figure):
        if PlotWindow._check_fig_in_list(fig):
            fig_num = fig.number
            close_status = PlotWindow._get_fig_info_in_list(fig)['closed']
            text = f"""Figure {fig_num}\nAxes: {len(fig.get_axes())}\nClosed: {close_status}"""
            self.info_window.setText(text)

    def _on_figure_selected(self, item: QListWidgetItem):
        """
        Update info window, possibly update a thumbnail?
        Args:
            item:

        Returns:

        """
        fig = item.data(Qt.ItemDataRole.UserRole)
        self._update_fig_list()
        self._update_info_panel(fig)

    def _on_figure_double_clicked(self, item: QListWidgetItem):
        fig = item.data(Qt.ItemDataRole.UserRole)
        self.show_figure_window(fig)

    def _open_context_menu(self, position):
        menu = QMenu(self)
        # close_action = menu.addAction("Close Figure")
        save_action = menu.addAction("Save Figure")

        selected_item = self.list_widget.itemAt(position)
        if selected_item is None:
            return

        fig = selected_item.data(Qt.ItemDataRole.UserRole)
        action = menu.exec(self.list_widget.mapToGlobal(position))

        if action is save_action:
            self._save_figure(fig)

    def _save_figure(self, fig: Figure):
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            f"Save Figure {fig.number}",
            f"figure_{fig.number}",
            "Images (*.png *.pdf *.svg)",
        )
        if file_path:
            if file_path.endswith(".pdf"):
                fig.savefig(file_path, format="pdf")
            elif file_path.endswith(".svg"):
                fig.savefig(file_path, format="svg")
            else:
                fig.savefig(file_path, format="png")

    def show_figure_window(self, fig: Figure):
        try:
            if PlotWindow._check_fig_in_list(fig):
                fig_record = PlotWindow._get_fig_info_in_list(fig)
                if "figure_window" not in fig_record:
                    window = FigureWindow(fig, parent=self)
                    PlotWindow._update_fig_info_in_list(fig, **{"figure_window": window})
                    window.show()
                else:
                    window = fig_record["figure_window"]
                    window.showNormal()

                window.raise_()
                window.activateWindow()
        except Exception as e:
            logger.error("Error when showing figure window")
            logger.exception(e, exc_info=True, stack_info=True)

    def show_window(self):
        self.showNormal()
        self.raise_()
        self.activateWindow()

    def force_close_all(self):
        reply = QMessageBox.question(
            self,
            "Confirm Exit",
            "Are you sure you want to close Plot Manager and all figures?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )
        if reply == QMessageBox.StandardButton.Yes:
            for fig_info in PlotWindow._figure_track_list.values():
                if "figure_window" in fig_info:
                    fig_info["figure_window"].close()
            self._figure_track_list.clear()
            self._figure_uid.clear()
            self.close()

    def closeEvent(self, event):
        if self.allow_full_close:
            self.force_close_all()
        else:
            self.hide()
            event.ignore()


# --- Test Script ---
if __name__ == "__main__":
    app = QApplication(sys.argv)

    plot_window = PlotWindow(allow_full_close=True)
    plot_window.show()

    fig1 = plt.figure(1)
    x = np.linspace(0, 2 * np.pi, 100)
    plt.plot(x, np.sin(x))
    plot_window.add_figure(fig1)

    fig2 = plt.figure(2)
    plt.plot(x, np.cos(x))
    plot_window.add_figure(fig2)

    fig3 = plt.figure(3)
    plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
    plot_window.add_figure(fig3)

    plt.close(fig1)
    sys.exit(app.exec())
